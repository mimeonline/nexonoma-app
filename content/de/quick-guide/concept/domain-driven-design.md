---
title: Domain Driven Design
updatedAt: 2025-12-19
contentType: quick-guide
assetType: concept
assetSlug: domain-driven-design
locale: de
version: 1.0.0
---
# QUICK GUIDE: Domain Driven Design

## Kurzfassung

Domain Driven Design (DDD) ist eine Methodik zur Entwicklung komplexer Softwaresysteme, die den Fokus konsequent auf das fachliche Verständnis der zugrundeliegenden Domäne legt. Anstatt technische Aspekte wie Datenbanken oder Benutzeroberflächen in den Mittelpunkt zu stellen, zielt DDD darauf ab, die Softwarearchitektur als direktes Abbild der fachlichen Realität zu gestalten. Es geht im Kern darum, die Lücke zwischen den Anforderungen der Fachexperten und der Implementierung durch die Entwickler zu schließen, indem ein gemeinsames, präzises Sprach- und Modellverständnis erarbeitet wird. Diese Ausrichtung verhindert, dass technischer Code und fachliche Intention auseinanderdriften, was in langlebigen Systemen oft zur Erosion der Wartbarkeit führt.

Der Ansatz unterteilt sich dabei in zwei wesentliche Disziplinen: das strategische und das taktische Design. Das strategische Design beschäftigt sich mit der groben Strukturierung großer Systeme, der Definition von Grenzen und dem Zusammenspiel verschiedener fachlicher Teilbereiche. Das taktische Design hingegen bietet konkrete Entwurfsmuster für die Modellierung der Geschäftslogik innerhalb dieser Grenzen. Durch die Anwendung von DDD wird Software nicht nur als eine Ansammlung von Funktionen betrachtet, sondern als ein evolvierendes Modell, das Wissen über Geschäftsprozesse und Regeln konserviert und ausführbar macht. Es ist somit weniger eine Technologie als vielmehr eine Kommunikations- und Organisationsphilosophie für die Softwareentwicklung.

## Worum geht es hier?

Im Zentrum von Domain Driven Design steht die Erkenntnis, dass die größte Herausforderung bei der Softwareentwicklung meist nicht in der Technik, sondern im Verständnis der Fachlichkeit liegt. Um diese Komplexität zu bewältigen, fordert DDD die kooperative Erstellung eines sogenannten Domänenmodells. Dieses Modell ist keine bloße grafische Darstellung oder ein Datenbankdiagramm, sondern ein abstraktes System aus Objekten, Verhaltensweisen und Zusammenhängen, das ein spezifisches Problem der realen Welt löst. Das Modell dient als "Single Source of Truth" für die Logik und muss frei von technischer Infrastruktur gehalten werden. Es repräsentiert das destillierte Wissen der Fachexperten, übersetzt in eine Struktur, die von Software verarbeitet werden kann.

Ein unverzichtbares Werkzeug hierfür ist die "Ubiquitous Language" (allgegenwärtige Sprache). In vielen Projekten existiert eine schädliche Übersetzungsleistung: Fachexperten sprechen von "Buchungen" und "Stornierungen", während Entwickler von "Tabelleneinträgen" und "Lösch-Flags" sprechen. DDD eliminiert diese Diskrepanz, indem es fordert, dass dieselbe Sprache in Gesprächen, in der Dokumentation und – das ist der entscheidende Punkt – im Programmcode selbst verwendet wird. Wenn sich die Fachsprache ändert, muss sich der Code ändern. Zusätzlich führt DDD das Konzept der "Bounded Contexts" ein. Dies erkennt an, dass ein einheitliches Modell für ein gesamtes Unternehmen illusorisch ist. Stattdessen werden explizite Grenzen definiert, innerhalb derer ein bestimmtes Modell und eine bestimmte Sprache gültig sind, wodurch Namenskonflikte und logische Inkonsistenzen in großen Systemen vermieden werden.

## Warum ist das relevant?

Die Relevanz von Domain Driven Design ergibt sich aus der stetig steigenden Komplexität moderner Geschäftsanwendungen und der Notwendigkeit, diese über lange Zeiträume wartbar zu halten. In traditionellen, datengetriebenen Entwicklungsansätzen neigt die Geschäftslogik dazu, über verschiedene Schichten der Anwendung zu diffundieren – Teile liegen in der Datenbank, Teile im UI-Code, Teile in Service-Schichten. Dies führt zu einer hohen kognitiven Last für Entwickler, da Änderungen an einem Geschäftsprozess oft Anpassungen an vielen, lose gekoppelten Stellen erfordern. Das Risiko, durch eine Änderung unbeabsichtigte Nebeneffekte auszulösen, steigt mit der Zeit exponentiell an, was oft als "Big Ball of Mud" bezeichnet wird.

DDD adressiert dieses Problem der Software-Entropie direkt durch Kapselung und Entkopplung basierend auf fachlichen Kriterien. Indem die Softwarearchitektur die fachlichen Grenzen (Bounded Contexts) respektiert, können Teams unabhängiger voneinander arbeiten, da Änderungen in einem Teilbereich nicht zwangsläufig Auswirkungen auf andere Bereiche haben. Zudem wird die Software durch die enge sprachliche Kopplung an die Fachdomäne selbsterklärend. Ein neuer Entwickler oder ein Fachexperte kann den Code lesen und verstehen, *was* das System tut, ohne sich erst durch technische Implementierungsdetails wie Caching-Strategien oder Persistenz-Frameworks wühlen zu müssen. Dies sichert Investitionen, da das im Code gegossene Wissen auch dann noch verständlich bleibt, wenn die ursprünglichen Autoren das Projekt verlassen haben.

## Wann einsetzen?

Domain Driven Design ist kein Universalwerkzeug für jede Art von Softwareprojekt, sondern entfaltet seinen Nutzen primär in Szenarien mit hoher fachlicher Komplexität. Es ist besonders dann indiziert, wenn die Geschäftslogik komplizierte Regeln, Abhängigkeiten und Zustandsübergänge beinhaltet, die nicht trivial sind. Typische Anwendungsfälle sind Kernsysteme in Branchen wie Logistik, Finanzen, Versicherungen oder e-Commerce, wo der Wettbewerbsvorteil direkt von der Flexibilität und Korrektheit der abgebildeten Prozesse abhängt. Wenn ein tiefes Verständnis der Domäne notwendig ist, um die Software überhaupt korrekt spezifizieren zu können, ist DDD der methodische Ansatz der Wahl, um dieses Verständnis iterativ zu erarbeiten und zu validieren.

Hingegen ist der Einsatz von DDD oft kontraproduktiv, wenn es sich um reine "CRUD"-Anwendungen (Create, Read, Update, Delete) handelt, bei denen im Wesentlichen Daten von einer Benutzeroberfläche in eine Datenbank und zurück bewegt werden, ohne dass dabei komplexe Validierungen oder Transformationen stattfinden. In solchen Fällen erzeugt die strikte Trennung von Domänenmodell und Infrastruktur sowie der Aufwand für die Modellierung einen unnötigen Overhead, der die Entwicklung verlangsamt, ohne einen entsprechenden Mehrwert zu bieten. Die Entscheidung für DDD sollte daher immer auf einer Analyse der "Domain Complexity" basieren, nicht auf der "Technical Complexity". Auch die organisatorische Bereitschaft ist ein Faktor: DDD erfordert zwingend den direkten Zugang zu Fachexperten. Wenn dieser Zugang fehlt, kann die Methodik nicht greifen.

## Abgrenzung & typische Missverständnisse

Ein häufiges Missverständnis ist die Gleichsetzung von Domain Driven Design mit bestimmten technischen Architekturmustern, insbesondere Microservices. Zwar passen DDD und Microservices gut zusammen, da Bounded Contexts natürliche Schnittstellen für Services bieten, doch bedingen sie einander nicht. Man kann einen exzellenten monolithischen Aufbau unter Verwendung von DDD realisieren (einen sogenannten "Modular Monolith"), und man kann Microservices bauen, die keinerlei DDD-Prinzipien folgen. DDD ist primär eine Design- und Kommunikationsstrategie, keine Infrastrukturentscheidung. Ein weiteres Missverständnis ist die Reduktion von DDD auf seine taktischen Muster wie "Entities", "Value Objects" oder "Repositories". Dies wird oft als "DDD Lite" bezeichnet. Das bloße Verwenden dieser Code-Strukturen ohne die strategische Arbeit an der Ubiquitous Language und den Bounded Contexts führt oft zu überkompliziertem Code ohne den eigentlichen Nutzen der besseren Fachlichkeits-Abbildung.

Zudem muss abgegrenzt werden, dass DDD nicht versucht, die gesamte Realität zu modellieren, sondern nur die für das Geschäftsproblem relevanten Aspekte. Ein Modell ist immer eine zweckgebundene Vereinfachung. Es gibt nicht "das eine wahre Modell" einer Domäne. In einem Versand-Kontext hat der Begriff "Kunde" eine völlig andere Bedeutung und Attribute (Lieferadresse, Packstation) als im Abrechnungs-Kontext (Rechnungsanschrift, Kreditwürdigkeit). Der Versuch, diese unterschiedlichen Bedeutungen in einer einzigen, globalen Klasse "Kunde" zu vereinen, ist ein Anti-Pattern, gegen das sich DDD explizit wendet. Die Stärke liegt gerade in der Akzeptanz von Polysemie (Mehrdeutigkeit) und deren saubere Trennung durch explizite Kontextgrenzen.

## Weiterführende Gedanken

Nach dem Verständnis der Grundprinzipien von DDD verlagert sich der Fokus in der Praxis oft auf die methodische Erarbeitung der Modelle. Hierbei spielen kollaborative Workshop-Formate eine zentrale Rolle. Methoden wie "Event Storming" oder "Domain Storytelling" dienen dazu, das implizite Wissen der Fachexperten zu explizieren und gemeinsam mit den Entwicklern eine visuelle Repräsentation der Prozesse zu erarbeiten, bevor die erste Zeile Code geschrieben wird. Diese Phase der Wissensdestillation ist entscheidend, um die Bounded Contexts korrekt zu schneiden und die Schnittstellen zwischen ihnen (Context Map) zu definieren.

Für die technische Umsetzung bietet sich im Anschluss die Beschäftigung mit Architekturstilen an, die die Isolation des Domänenmodells begünstigen. Hier ist vor allem die Hexagonale Architektur (Ports & Adapters) oder die Onion Architecture zu nennen. Diese Stile erzwingen technisch, was DDD logisch fordert: Die Abhängigkeitsrichtung zeigt immer von außen (Infrastruktur, UI) nach innen (Domäne). Das Verständnis dieser architektonischen Zwiebelschalenmodelle ist der logische nächste Schritt, um ein theoretisch erarbeitetes Domänenmodell in eine widerstandsfähige Applikationsstruktur zu überführen. Es lohnt sich, die Wechselwirkungen zwischen dem strategischen Schnitt der Systeme und der Organisationsstruktur der entwickelnden Teams (Conway's Law) tiefergehend zu betrachten.
